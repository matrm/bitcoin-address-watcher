<!DOCTYPE html>
<html lang="en">

<head>

	<title>Bitcoin Address Watcher</title>

	<script>

		class AddressInfo {
			constructor(address = '', label = '', note = '', balanceLastUpdate = null, balance = null, spent = null) {
				this.address = address;
				this.label = label;
				this.note = note;
				this.balanceLastUpdate = balanceLastUpdate;
				this.balance = balance;
				this.spent = spent;
			}
			get balanceChange() {
				return this.balanceLastUpdate == null && this.balance == null
					? 0
					: (
						this.balance
						? (
							// balanceLastUpdate may still be null. balance is > 0.
							// Uses 0 when first time updating balance (when balanceLastUpdate is null).
							// Safe to change the ': 0' to ': this.balance'.
							this.balanceLastUpdate ? this.balance - this.balanceLastUpdate : 0
						)
						: 0
					);
			}
		}

		const ADDRESS_INFOS_LOCAL_STORAGE_KEY = 'addressInfos';
		const PRICE_LOCAL_STORAGE_KEY = 'price';

		let confirmDeletingAddressAfterTime = new Date().getTime();

		function setAddressInfosInLocalStorage(addressInfos) {
			console.assert(Array.isArray(addressInfos));
			localStorage.setItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY, JSON.stringify(addressInfos));
		}

		function getAddressInfosFromLocalStorage() {
			const addressInfosString = localStorage.getItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY);
			if (addressInfosString) {
				try {
					const parsedJSON = JSON.parse(addressInfosString);
					const addressInfos = [];
					for (let addressInfoData of parsedJSON) {
						// Convert to new AddressInfo because the serialized json has no functions.
						const addressInfo = new AddressInfo();
						Object.assign(addressInfo, addressInfoData);
						addressInfos.push(addressInfo);
					}
					return addressInfos;
				} catch (err) {
					console.log('Unable to parse address info from localStorage:', err.message);
				}
			}
			return [];
		}

		function setPriceInLocalStorage(price) {
			if (price == null) {
				return;
			}
			console.assert(typeof price == 'number');
			localStorage.setItem(PRICE_LOCAL_STORAGE_KEY, price.toString());
		}

		function getPriceFromLocalStorage() {
			const priceString = localStorage.getItem(PRICE_LOCAL_STORAGE_KEY);
			if (priceString) {
				try {
					return parseFloat(priceString);
				} catch (err) {
					console.log('Unable to parse price from localStorage:', err.message);
				}
			}
			return null;
		}

		function backupToFile() {
			const suggestedFileName = 'bitcoin-address-watcher-backup-' + Math.floor(Date.now() / 1000).toString() + '.json';

			localStorageString = (() => {
				const ls = {};
				for (var i = 0; i < localStorage.length; i++) {
					var k = localStorage.key(i);
					var v = localStorage.getItem(k);
					ls[k] = v;
				}
				return JSON.stringify(ls);
			})();

			// https://stackoverflow.com/a/18197341
			const element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(localStorageString));
			element.setAttribute('download', suggestedFileName);
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		}

		async function fetchPrice() {
			const url = 'https://api.blockchair.com/bitcoin-sv/stats';

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for price rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					const market_cap_usd = data.market_cap_usd;
					const circulation = data.circulation;
					if (typeof market_cap_usd != 'number' || typeof circulation != 'number' || circulation < 1763916464692325) {
						throw new Error(`Unable to derive price from market cap of ${market_cap_usd} and circulation of ${circulation}`);
					}
					return market_cap_usd / circulation;
				});
		}

		async function fetchAddressBalances(addressInfos) {
			if (addressInfos.length == 0) {
				return;
			}

			// Convert AddressInfo array to address (string) array.
			const addresses = addressInfos.map(addressInfo => addressInfo.address);

			// Addresses can be comma-separated values.
			const url = `https://api.bitindex.network/api/v2/addrs/balance?address=${addresses.join(',')}`;

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for address info rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					/* Example responseJSON:
						{
							"data": [
								{
									"address": "1BitcoinEaterAddressDontSendf59kuE",
									"confirmed": 63791,
									"unconfirmed": 0
								},
								{
									"address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
									"confirmed": 1392000,
									"unconfirmed": 144237
								}
							]
						}
					*/
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					if (!Array.isArray(data) || data.length != addressInfos.length) {
						throw new Error('Invalid data received when fetching address balances');
					}
					for (let i = 0; i < data.length; i++) {
						const confirmed = data[i].confirmed;
						const unconfirmed = data[i].unconfirmed;
						if (typeof confirmed == 'number' && typeof unconfirmed == 'number') {
							addressInfos[i].balanceLastUpdate = addressInfos[i].balance;
							addressInfos[i].balance = confirmed + unconfirmed;
						}
						// addressInfos[i].balance may be a number or the default initial value.
					}
				});
		}

		// Requests both at the same time.
		async function fetchAddressInfosAndPrice(addressInfos) {
			// Start fetching price now. To be 'await'ed later.
			const pricePromise = fetchPrice()
				.catch(error => {
					const errorMessage = `Error fetching price: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
					return getPriceFromLocalStorage();
				});

			await fetchAddressBalances(addressInfos);

			const price = await pricePromise;

			return { addressInfos, price };
		}

		function render(addressInfos, price) {
			setAddressInfosInLocalStorage(addressInfos);
			setPriceInLocalStorage(price);

			const totalBalance = addressInfos.reduce((t, address) => t + address.balance || 0, 0);
			const totalBalanceChange = addressInfos.reduce((t, address) => t + address.balanceChange, 0);
			const totalValuation = addressInfos.reduce((t, address) => t + (address.balance && price ? address.balance * price : 0), 0);
			const totalBalanceDisplayString = totalBalance.toLocaleString();
			const totalValuationDisplayString = totalValuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

			document.getElementById('totalBalanceHeader').innerHTML = `Balance: ${totalBalanceDisplayString}`;
			document.getElementById('totalValuationHeader').innerHTML = `${totalValuationDisplayString} USD`;

			const addressesTable = document.getElementById("addressesTable");

			if (addressInfos.length == 0) {
				addressesTable.innerHTML = '';
				addressesTable.style.display = 'none';
				return;
			}

			addressesTable.style.display = '';

			let tableInnerHTML = "<tr><th></th><th>Label</th><th>Address</th><th>Balance</th><th>USD</th><th></th></tr>";

			for (let i = 0; i < addressInfos.length; i++) {
				const balanceLastUpdate = addressInfos[i].balanceLastUpdate;
				const balance = addressInfos[i].balance;
				const balanceChange = addressInfos[i].balanceChange;
				if (balanceChange != 0) {
					console.log(`Balance change for address ${i + 1}: ${balanceChange} (from ${balanceLastUpdate} to ${balance}).`);
				}
				const valuation = balance == null || price == null ? null : balance * price;
				const balanceDisplayString = balance == null ? '' : balance.toLocaleString();
				const valuationDisplayString = valuation == null ? '' : valuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

				// Hover text using AddressInfo note.
				const addressNoteTitleHTML = addressInfos.note ? ' title="' + addressInfos.note + '"' : '';

				const balanceTableDataColorClass = balanceChange == 0 ? '' : (balanceChange > 0 ? ' increaseColor' : ' decreaseColor');
				const balanceTableDataTitle = balanceChange == 0 ? '' : ` title="${(balanceChange > 0 ? '+' + balanceChange.toLocaleString() : '-' + Math.abs(balanceChange).toLocaleString())}"`;
				const balanceTableData = `<td class="textRight${balanceTableDataColorClass}"${balanceTableDataTitle}>${balanceDisplayString}</td>`;

				tableInnerHTML +=
					`<tr>
						<td><button type="button" class="deleteAddressButton" title="Remove address ${i + 1}" onclick="removeAddressInfosIndex(${i})">X</button></td>
						<td${addressNoteTitleHTML} style="padding: 0;"><input type="text" class="labelInput" onchange="updateAddressInfosLabelFromIndex(${i}, this.value)" value="${addressInfos[i].label}"></td>
						<td class="textLeft">${addressInfos[i].address}</td>
						${balanceTableData}
						<td class="textRight">${valuationDisplayString}</td>
						<td><a href="https://blockchair.com/bitcoin-sv/address/${addressInfos[i].address}" target="_blank" title="View on block explorer"><img src="https://blockchair.com/favicon.ico" alt="View"></a></td>
					</tr>`;
			}

			if (addressInfos.length > 1) {
				if (totalBalanceChange != 0) {
					console.log(`Total balance change: ${totalBalanceChange}.`);
				}

				const totalBalanceTableDataColorClass = totalBalanceChange == 0 ? '' : (totalBalanceChange > 0 ? ' increaseColor' : ' decreaseColor');
				const totalBalanceTableDataTitle = totalBalanceChange == 0 ? '' : ` title="${(totalBalanceChange > 0 ? '+' + totalBalanceChange.toLocaleString() : '-' + Math.abs(totalBalanceChange).toLocaleString())}"`;
				const totalBalanceTableData = `<td class="textRight${totalBalanceTableDataColorClass}"${totalBalanceTableDataTitle}>${totalBalanceDisplayString}</td>`;

				tableInnerHTML +=
					`<tr>
						<th></th>
						<th></th>
						<th class="textRight">Total:</th>
						${totalBalanceTableData}
						<td class="textRight">${totalValuationDisplayString}</td>
						<th></th>
					</tr>`;
			}

			addressesTable.innerHTML = tableInnerHTML;
		}

		function removeAddressInfosIndex(index) {
			if (
				new Date().getTime() > confirmDeletingAddressAfterTime &&
				!confirm(`Remove address ${index + 1}?`)
			) {
				// Prevent accidentally removing an address.
				return;
			}
			const addressInfos = getAddressInfosFromLocalStorage();
			const price = getPriceFromLocalStorage();
			addressInfos.splice(index, 1);
			render(addressInfos, price);
			confirmDeletingAddressAfterTime = new Date().getTime() + 3000;
		}

		function updateAddressInfosLabelFromIndex(index, label) {
			const addressInfos = getAddressInfosFromLocalStorage();
			addressInfos[index].label = label;
			setAddressInfosInLocalStorage(addressInfos);
		}

		// Download balance for each new AddressInfo, update price, and then update UI.
		function setupAddressInfosAndRender(addressInfos, scrollOnSuccess = false) {
			fetchAddressInfosAndPrice(addressInfos)
				.then(addressInfosAndPrice => {
					render(addressInfosAndPrice.addressInfos, addressInfosAndPrice.price);
					if (scrollOnSuccess) {
						window.scrollTo(0, document.body.scrollHeight);
					}
				})
				.catch(error => {
					const errorMessage = `Error fetching address balances: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
				});
		}

		function renderUpdateRender() {
			const addressInfos = getAddressInfosFromLocalStorage();

			// Unset all the balanceLastUpdate because rendering balance changes the first time is pointless.
			const defaultBalanceLastUpdate = new AddressInfo().balanceLastUpdate;
			for (let addressInfo of addressInfos) {
				addressInfo.balanceLastUpdate = defaultBalanceLastUpdate;
			}

			// Render before fetching any external data.
			render(addressInfos, getPriceFromLocalStorage());

			if (addressInfos.length) {
				setupAddressInfosAndRender(addressInfos);
			}
		}

		function loadFromFileAndRender(inputTarget) {
			// https://stackoverflow.com/a/29176118
			const reader = new FileReader();
			reader.onload = function () {
				const text = reader.result;
				try {
					const parsedJSON = JSON.parse(text);
					for (const [key, value] of Object.entries(parsedJSON)) {
						localStorage.setItem(key, value);
					}
					console.log('Loaded from file.');
					renderUpdateRender();
				} catch (err) {
					console.log('Unable to parse JSON backup file:', err.message);
				}
			};
			reader.onerror = function (event) {
				reader.abort();
				const errorMessage = 'Error reading file.';
				console.log(errorMessage);
				alert(errorMessage);
			};
			reader.readAsText(inputTarget.files[0]);
			inputTarget.value = '';// Reset value so onchange() works when reloading from file again.
		}

		window.onload = function () {
			document.getElementById('addAddressesButton').onclick = function () {
				const inputAddresses = document.getElementById("inputAddresses");
				const addresses = inputAddresses.value
					.split(',')
					.map(a => a.replace(/[^A-Z0-9]+/ig, ''))// Remove undesirable characters.
					.filter(a => a.length != 0);// Remove empty addresses.

				if (addresses.length == 0) {
					alert(`No valid addresses to add.`);
					return;
				}

				inputAddresses.value = '';

				// Convert addresses to AddressInfo objects and combine with the AddressInfos from localStorage.
				const addressInfos = getAddressInfosFromLocalStorage().concat(addresses.map(a => new AddressInfo(a)));

				setupAddressInfosAndRender(addressInfos, /* scrollOnSuccess */true);
			};

			// Hide table before loading data.
			document.getElementById('addressesTable').style.display = 'none';

			renderUpdateRender();
		}

	</script>

	<style>
		body {
			background-color: #000;
			color: #ccc;
			text-align: center;
		}

		table {
			background: #002;
			margin: 0 auto;
			border: 0.1em solid #666;
			border-spacing: 0.2em;
		}

		th {
			background-color: #008;
			color: #ddd;
			vertical-align: middle;
			padding: 0.2em;
			font-size: 1.2em;
		}

		td {
			background-color: #006;
			color: #eee;
			vertical-align: middle;
			padding: 0.2em;
			font-family: "Courier New", Courier, monospace;
		}

		td img {
			display: block;
			height: 100%;
			width: auto;
		}

		a,
		a:visited,
		a:hover,
		a:active {
			color: inherit;
		}

		.container {
			margin: 0 auto 10em;
			display: inline-block;
		}

		.textLeft {
			text-align: left;
		}

		.textRight {
			text-align: right;
		}

		td.textRight,
		td.textLeft {
			padding-left: 0.6em;
			padding-right: 0.6em;
		}

		.increaseColor {
			color: #0d0;
		}

		.decreaseColor {
			color: #d00;
		}

		.deleteAddressButton {
			background-color: #000;
			color: #d00;
			border: 0.1em solid #666;
			border-radius: 0.3em;
			font-size: 1em;

		}

		.labelInput {
			background-color: #000;
			color: #ddd;
			border: 0.1em solid #666;
			text-align: center;
			padding: 0.05em 0.4em;
			text-decoration: none;
			font: 400 1.1em Arial;
			text-rendering: auto;
			letter-spacing: normal;
			word-spacing: normal;
			text-transform: none;
			text-indent: 0px;
			text-shadow: none;
			display: inline-block;
		}
	</style>

</head>

<body>

	<div class="container">

		<h1 id="totalBalanceHeader"></h1>
		<h1 id="totalValuationHeader"></h1>

		<div style="text-align: center; margin-bottom: 1em;">
			<input id="inputAddresses" class="labelInput" type="text" size="64"
				placeholder="Input one or more addresses separated by commas" />
			<input id="addAddressesButton" class="labelInput" type="button" value="Add Addresses" />
		</div>

		<table id="addressesTable">
		</table>

		<input id="saveBackupFileButton" style="margin-top: 1em;" class="labelInput" type="button" value="Save Backup File" onclick="backupToFile()" />

		<label class="labelInput" style="margin-top: 1em;">
			<input id="loadBackupFileButton" style="display: none;" type="file" accept=".json,.txt" onchange="loadFromFileAndRender(event.target)" />
			Load Backup File
		</label>

	</div>

</body>

</html>