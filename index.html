<!DOCTYPE html>
<html lang="en">

<head>

	<title>Bitcoin Address Watcher</title>

	<script>

		class AddressInfo {
			constructor(address = '', label = '', note = '', balanceLastUpdate = null, balance = null, spent = null) {
				this.address = address;
				this.label = label;
				this.note = note;
				this.balanceLastUpdate = balanceLastUpdate;
				this.balance = balance;
				this.spent = spent;
			}
			get balanceChange() {
				return this.balanceLastUpdate == null || this.balance == null ? 0 : this.balance - this.balanceLastUpdate;
			}
		}

		const ADDRESS_INFOS_LOCAL_STORAGE_KEY = 'addressInfos';
		const PRICE_LOCAL_STORAGE_KEY = 'price';

		let confirmDeletingAddressAfterTime = new Date().getTime();

		function setAddressInfosInLocalStorage(addressInfos) {
			console.assert(Array.isArray(addressInfos));
			localStorage.setItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY, JSON.stringify(addressInfos));
		}

		function getAddressInfosFromLocalStorage() {
			const addressInfosString = localStorage.getItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY);
			if (addressInfosString) {
				try {
					const parsedJSON = JSON.parse(addressInfosString);
					const addressInfos = [];
					for (let addressInfoData of parsedJSON) {
						// Convert to new AddressInfo because the serialized json has no functions.
						const addressInfo = new AddressInfo();
						Object.assign(addressInfo, addressInfoData);
						addressInfos.push(addressInfo);
					}
					return addressInfos;
				} catch (err) {
					console.log('Unable to parse address info from localStorage:', err.message);
					console.log(addressInfosString);
				}
			}
			return [];
		}

		function setPriceInLocalStorage(price) {
			if (price == null) {
				return;
			}
			console.assert(typeof price == 'number');
			localStorage.setItem(PRICE_LOCAL_STORAGE_KEY, price.toString());
		}

		function getPriceFromLocalStorage() {
			const priceString = localStorage.getItem(PRICE_LOCAL_STORAGE_KEY);
			if (priceString) {
				try {
					return parseFloat(priceString);
				} catch (err) {
					console.log('Unable to parse price from localStorage:', err.message);
				}
			}
			return null;
		}

		function backupToFile() {
			const suggestedFileName = 'bitcoin-address-watcher-backup-' + Math.floor(Date.now() / 1000).toString() + '.json';

			localStorageString = (() => {
				const ls = {};
				for (var i = 0; i < localStorage.length; i++) {
					var k = localStorage.key(i);
					var v = JSON.parse(localStorage.getItem(k));
					ls[k] = v;
				}
				return JSON.stringify(ls, null, '\t');
			})();

			// https://stackoverflow.com/a/18197341
			const element = document.createElement('a');
			element.setAttribute('href', 'data:text/plain;charset=utf-8,' + localStorageString);
			element.setAttribute('download', suggestedFileName);
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		}

		async function fetchPrice() {
			const url = 'https://api.blockchair.com/bitcoin-sv/stats';

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for price rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					const market_cap_usd = data.market_cap_usd;
					const circulation = data.circulation;
					if (typeof market_cap_usd != 'number' || typeof circulation != 'number' || circulation < 1763916464692325) {
						throw new Error(`Unable to derive price from market cap of ${market_cap_usd} and circulation of ${circulation}`);
					}
					return market_cap_usd / circulation;
				});
		}

		async function fetchAddressBalances(addressInfos) {
			if (addressInfos.length == 0) {
				return;
			}

			// Convert AddressInfo array to address (string) array.
			const addresses = addressInfos.map(addressInfo => addressInfo.address);

			// Addresses can be comma-separated values.
			const url = `https://api.bitindex.network/api/v2/addrs/balance?address=${addresses.join(',')}`;

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for address info rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					/* Example responseJSON:
						{
							"data": [
								{
									"address": "1BitcoinEaterAddressDontSendf59kuE",
									"confirmed": 63791,
									"unconfirmed": 0
								},
								{
									"address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
									"confirmed": 1392000,
									"unconfirmed": 144237
								}
							]
						}
					*/
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					if (!Array.isArray(data) || data.length != addressInfos.length) {
						throw new Error('Invalid data received when fetching address balances');
					}
					for (let i = 0; i < data.length; i++) {
						const confirmed = data[i].confirmed;
						const unconfirmed = data[i].unconfirmed;
						if (typeof confirmed == 'number' && typeof unconfirmed == 'number') {
							addressInfos[i].balanceLastUpdate = addressInfos[i].balance;
							addressInfos[i].balance = confirmed + unconfirmed;
						}
						// addressInfos[i].balance may be a number or the default initial value.
					}
				});
		}

		// Requests both at the same time.
		async function fetchAddressInfosAndPrice(addressInfos) {
			// Start fetching price now. To be 'await'ed later.
			const pricePromise = fetchPrice()
				.catch(error => {
					const errorMessage = `Error getting price: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
					return getPriceFromLocalStorage();
				});

			await fetchAddressBalances(addressInfos);

			const price = await pricePromise;

			return { addressInfos, price };
		}

		function render(addressInfos, price) {
			setAddressInfosInLocalStorage(addressInfos);
			setPriceInLocalStorage(price);

			const totalBalance = addressInfos.reduce((t, address) => t + address.balance || 0, 0);
			const totalBalanceChange = addressInfos.reduce((t, address) => t + address.balanceChange, 0);
			const totalValuation = addressInfos.reduce((t, address) => t + (address.balance && price ? address.balance * price : 0), 0);
			const totalBalanceDisplayString = totalBalance.toLocaleString();
			const totalValuationDisplayString = totalValuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

			document.getElementById('totalBalanceHeader').innerHTML = `Balance: ${totalBalanceDisplayString}`;
			document.getElementById('totalValuationHeader').innerHTML = `${totalValuationDisplayString} USD`;

			const addressesTableContainer = document.getElementById('addressesTableContainer');

			while (addressesTableContainer.firstChild) {
				// Remove current table. https://stackoverflow.com/a/3955238
				addressesTableContainer.removeChild(addressesTableContainer.firstChild);
			}

			if (addressInfos.length == 0) {
				return;
			}

			const addressesTable = document.createElement('table');
			addressesTable.classList.add('standardMargin');

			// First row.
			addressesTable.appendChild((() => {
				const tr = document.createElement('tr');
				tr.appendChild(document.createElement('th'));
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Label'));
					return th;
				})());
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Address'));
					return th;
				})());
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Balance'));
					return th;
				})());
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('USD'));
					return th;
				})());
				tr.appendChild(document.createElement('th'));
				return tr;
			})());

			for (let i = 0; i < addressInfos.length; i++) {
				const addressInfo = addressInfos[i];
				const balanceLastUpdate = addressInfo.balanceLastUpdate;
				const balance = addressInfo.balance;
				const balanceChange = addressInfo.balanceChange;
				const valuation = balance == null || price == null ? null : balance * price;
				const balanceDisplayString = balance == null ? '' : balance.toLocaleString();
				const valuationDisplayString = valuation == null ? '' : valuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

				if (balanceChange != 0) {
					console.log(`Balance change for address ${i + 1}: ${balanceChange} (from ${balanceLastUpdate} to ${balance}).`);
				}

				addressesTable.appendChild((() => {
					const tr = document.createElement('tr');
					tr.appendChild((() => {
						// Delete address button.
						const td = document.createElement('td');
						td.classList.add('tdWithInput');
						td.appendChild((() => {
							const button = document.createElement('button');
							button.classList.add('labelInput');
							button.classList.add('labelInputButton');
							button.classList.add('deleteAddressButton');
							button.type = 'button';
							button.title = `Remove address ${i + 1}`;
							button.appendChild(document.createTextNode('X'));
							button.onclick = () => { removeAddressInfosIndex(i); };
							return button;
						})());
						return td;
					})());
					tr.appendChild((() => {
						// Label input.
						const td = document.createElement('td');
						td.classList.add('tdWithInput');
						td.appendChild((() => {
							const input = document.createElement('input');
							input.classList.add('labelInput');
							input.type = 'text';
							input.title = `Remove address ${i + 1}`;
							input.value = addressInfo.label;
							input.onchange = () => { updateAddressInfosLabelFromIndex(i, input.value); };
							return input;
						})());
						return td;
					})());
					tr.appendChild((() => {
						// Address.
						const td = document.createElement('td');
						td.classList.add('textLeft');
						if (addressInfo.note) {
							// Hover text using AddressInfo note.
							td.title = addressInfo.note;
						}
						td.appendChild(document.createTextNode(addressInfo.address));
						return td;
					})());
					tr.appendChild((() => {
						// Balance.
						const td = document.createElement('td');
						td.classList.add('textRight');
						if (balanceChange != 0) {
							td.classList.add(balanceChange > 0 ? 'increaseColor' : 'decreaseColor');
							td.title = balanceChange > 0 ? `+${balanceChange.toLocaleString()}` : `-${Math.abs(balanceChange).toLocaleString()}`;
						}
						td.appendChild(document.createTextNode(balanceDisplayString));
						return td;
					})());
					tr.appendChild((() => {
						// USD.
						const td = document.createElement('td');
						td.classList.add('textRight');
						td.appendChild(document.createTextNode(valuationDisplayString));
						return td;
					})());
					tr.appendChild((() => {
						// Block explorer link.
						const td = document.createElement('td');
						td.classList.add('tdImageButton');
						td.appendChild((() => {
							const a = document.createElement('a');
							a.href = `https://blockchair.com/bitcoin-sv/address/${addressInfo.address}`;
							a.target = '_blank';
							a.title = 'View on block explorer';
							a.appendChild((() => {
								const img = document.createElement('img');
								img.src = 'https://blockchair.com/favicon.ico';
								img.alt = 'View';
								return img;
							})());
							return a;
						})());
						return td;
					})());
					return tr;
				})());
			}

			if (addressInfos.length > 1) {
				if (totalBalanceChange != 0) {
					console.log(`Total balance change: ${totalBalanceChange}.`);
				}

				// Last row.
				addressesTable.appendChild((() => {
					const tr = document.createElement('tr');
					tr.appendChild(document.createElement('th'));
					tr.appendChild(document.createElement('th'));
					tr.appendChild((() => {
						const th = document.createElement('th');
						th.classList.add('textRight');
						th.appendChild(document.createTextNode('Total:'));
						return th;
					})());
					tr.appendChild((() => {
						// Total balance.
						const td = document.createElement('td');
						td.classList.add('textRight');
						if (totalBalanceChange != 0) {
							td.classList.add(totalBalanceChange > 0 ? 'increaseColor' : 'decreaseColor');
							td.title = totalBalanceChange > 0 ? `+${totalBalanceChange.toLocaleString()}` : `-${Math.abs(totalBalanceChange).toLocaleString()}`;
						}
						td.appendChild(document.createTextNode(totalBalanceDisplayString));
						return td;
					})());
					tr.appendChild((() => {
						// Total USD.
						const td = document.createElement('td');
						td.classList.add('textRight');
						td.appendChild(document.createTextNode(totalValuationDisplayString));
						return td;
					})());
					tr.appendChild(document.createElement('th'));
					return tr;
				})());
			}

			addressesTableContainer.appendChild(addressesTable);
		}

		function removeAddressInfosBalanceOfZero() {
			if (!confirm('Remove addresses with a balance of 0?')) {
				return;
			}
			render(
				getAddressInfosFromLocalStorage().filter(address => address.balance),
				getPriceFromLocalStorage()
			);
		}

		function removeAddressInfosWithPromptLabel() {
			const input = prompt('Enter a label to remove or leave blank to remove unlabeled.');
			if (input == null) {
				return;
			}
			render(
				getAddressInfosFromLocalStorage().filter(address => address.label != input),
				getPriceFromLocalStorage()
			);
		}

		function removeAddressInfos() {
			if (!confirm('Remove all addresses?')) {
				return;
			}
			render(/* addressInfos */[], getPriceFromLocalStorage());
		}

		function removeAddressInfosIndex(index) {
			if (
				new Date().getTime() > confirmDeletingAddressAfterTime &&
				!confirm(`Remove address ${index + 1}?`)
			) {
				// Prevent accidentally removing an address.
				return;
			}
			const addressInfos = getAddressInfosFromLocalStorage();
			const price = getPriceFromLocalStorage();
			addressInfos.splice(index, 1);
			render(addressInfos, price);
			confirmDeletingAddressAfterTime = new Date().getTime() + 3000;
		}

		function updateAddressInfosLabelFromIndex(index, label) {
			const addressInfos = getAddressInfosFromLocalStorage();
			addressInfos[index].label = label;
			setAddressInfosInLocalStorage(addressInfos);
		}

		// Download balance for each new AddressInfo, update price, and then update UI.
		function setupAddressInfosAndRender(addressInfos, scrollOnSuccess = false) {
			fetchAddressInfosAndPrice(addressInfos)
				.then(addressInfosAndPrice => {
					render(addressInfosAndPrice.addressInfos, addressInfosAndPrice.price);
					if (scrollOnSuccess) {
						window.scrollTo(0, document.body.scrollHeight);
					}
				})
				.catch(error => {
					const errorMessage = `Error getting address balances: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
				});
		}

		function renderUpdateRender() {
			const addressInfos = getAddressInfosFromLocalStorage();

			// Unset all the balanceLastUpdate because rendering balance changes the first time is pointless.
			const defaultBalanceLastUpdate = new AddressInfo().balanceLastUpdate;
			for (let addressInfo of addressInfos) {
				addressInfo.balanceLastUpdate = defaultBalanceLastUpdate;
			}

			// Render before fetching any external data.
			render(addressInfos, getPriceFromLocalStorage());

			if (addressInfos.length) {
				setupAddressInfosAndRender(addressInfos);
			}
		}

		function loadFromFileAndRender(inputTarget) {
			// https://stackoverflow.com/a/29176118
			const reader = new FileReader();
			reader.onload = function () {
				const text = reader.result;
				try {
					const parsedJSON = JSON.parse(text);
					for (const [key, value] of Object.entries(parsedJSON)) {
						localStorage.setItem(key, JSON.stringify(value));
					}
					console.log('Loaded from file.');
					renderUpdateRender();
				} catch (err) {
					console.log('Unable to parse JSON backup file:', err.message);
				}
			};
			reader.onerror = function (event) {
				reader.abort();
				const errorMessage = 'Error reading file.';
				console.log(errorMessage);
				alert(errorMessage);
			};
			reader.readAsText(inputTarget.files[0]);
			inputTarget.value = '';// Reset value so onchange() works when reloading from file again.
		}

		function addInputAddresses() {
			const inputAddresses = document.getElementById("inputAddresses");
			const addresses = inputAddresses.value
				.split(',')
				.map(a => a.replace(/[^A-Z0-9]+/ig, ''))// Remove undesirable characters.
				.filter(a => a.length != 0);// Remove empty addresses.

			if (addresses.length == 0) {
				alert(`No valid addresses to add.`);
				return;
			}

			inputAddresses.value = '';

			// Convert addresses to AddressInfo objects and combine with the AddressInfos from localStorage.
			const addressInfos = getAddressInfosFromLocalStorage().concat(addresses.map(a => new AddressInfo(a)));

			setupAddressInfosAndRender(addressInfos, /* scrollOnSuccess */true);
		}

		window.onload = function () {
			renderUpdateRender();
		}

	</script>

	<style>
		body {
			background-color: #000;
			color: #ccc;
			text-align: center;
		}

		table {
			background: #002;
			border: 0.1em solid #666;
			border-spacing: 0.2em;
			border-radius: 0.6em;
		}

		th {
			background-color: #005;
			color: #ddd;
			vertical-align: middle;
			padding: 0.2em;
			font-size: 1.2em;
		}

		td {
			background-color: #004;
			color: #eee;
			vertical-align: middle;
			padding: 0.2em;
			font-family: "Courier New", Courier, monospace;
			min-width: 1.6em;
		}

		td img {
			display: block;
			object-fit: contain;
			height: 1.6em;
			max-width: 16em;
			margin: 0 auto;
		}

		a,
		a:visited,
		a:hover,
		a:active {
			color: inherit;
		}

		.container {
			margin: 0 auto 10em;
			display: inline-block;
		}

		.textLeft {
			text-align: left;
		}

		.textRight {
			text-align: right;
		}

		td.textRight,
		td.textLeft {
			padding-left: 0.6em;
			padding-right: 0.6em;
		}

		td.tdWithInput {
			padding: 0;
			background-color: transparent;
		}

		td.tdImageButton {
			padding: 0;
		}

		button.deleteAddressButton {
			color: #d00;
		}

		.increaseColor {
			color: #0d0;
		}

		.decreaseColor {
			color: #d00;
		}

		.labelInput {
			background-color: #000;
			color: #ddd;
			border: 0.1em solid #666;
			text-align: center;
			padding: 0.1em 0.4em;
			text-decoration: none;
			font: 400 1.1em Arial;
			text-rendering: auto;
			letter-spacing: normal;
			word-spacing: normal;
			text-transform: none;
			text-indent: 0px;
			text-shadow: none;
			display: inline-block;
			border-radius: 0.3em;
		}

		.labelInputButton {
			cursor: pointer;
		}

		.labelInputButton:hover {
			background-color: #005;
		}

		.standardMargin {
			margin: 0.5em 0.16em 0;
		}
	</style>

</head>

<body>

	<div class="container">

		<h1 id="totalBalanceHeader"></h1>
		<h1 id="totalValuationHeader"></h1>

		<input id="inputAddresses" class="labelInput" type="text" size="64"
			placeholder="Input one or more addresses separated by commas" />
		<input class="labelInput labelInputButton" type="button" value="Add Addresses" onclick="addInputAddresses()" />

		<div id="addressesTableContainer"></div>

		<input class="labelInput labelInputButton standardMargin" type="button" value="Remove Specific Label"
			onclick="removeAddressInfosWithPromptLabel()" />

		<input class="labelInput labelInputButton standardMargin" type="button" value="Remove Valueless"
			onclick="removeAddressInfosBalanceOfZero()" />

		<input class="labelInput labelInputButton standardMargin" type="button" value="Remove All"
			onclick="removeAddressInfos()" />

		<br>

		<input class="labelInput labelInputButton standardMargin" type="button" value="Export"
			onclick="backupToFile()" />

		<label class="labelInput labelInputButton standardMargin">
			<input style="display: none;" type="file" accept=".json,.txt"
				onchange="loadFromFileAndRender(event.target)" />
			Import
		</label>

		<br>

	</div>

</body>

</html>