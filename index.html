<!DOCTYPE html>
<html lang="en">

<head>

	<meta charset="UTF-8">

	<title>Bitcoin Address Watcher</title>

	<script>

		class AddressInfo {
			constructor(address = '', label = '', note = '', balanceLastUpdate = null, balance = null, spent = null) {
				this.address = address;
				this.label = label;
				this.note = note;
				this.balanceLastUpdate = balanceLastUpdate;
				this.balance = balance;
				this.spent = spent;
			}
			get balanceChange() {
				return this.balanceLastUpdate == null || this.balance == null ? 0 : this.balance - this.balanceLastUpdate;
			}
		}

		const ADDRESS_INFOS_LOCAL_STORAGE_KEY = 'addressInfos';
		const PRICE_LOCAL_STORAGE_KEY = 'price';

		let confirmDeletingAddressAfterTime = Date.now();

		// Prevent collisions with sites on the same domain.
		const localStorageNamespaced = {
			_localStorageKey: 'matrm-bitcoin-address-watcher',
			_storage: null,
			_getStorageObject() {
				if (this._storage) {
					return this._storage;
				}
				const storageString = localStorage.getItem(this._localStorageKey) || '{}';
				this._storage = {};
				try {
					this._storage = JSON.parse(storageString);
				} catch (err) {
					console.log('Unable to parse localStorage:', err.message);
					console.log(storageString);
					console.log('Resetting localStorage.');
					localStorage.clear();
				}
				return this._storage;
			},
			setStorageObject(storage) {
				localStorage.setItem(this._localStorageKey, JSON.stringify(storage));
				this._storage = storage;
			},
			setItem(k, v) {
				const storage = this._getStorageObject();
				storage[k] = v;
				this.setStorageObject(storage);
			},
			getItem(k) {
				const storage = this._getStorageObject();
				const item = storage[k];
				if (item == undefined) {
					return null;
				}
				return item;
			},
			toFormattedString() {
				return JSON.stringify(this._getStorageObject(), null, '\t');
			}
		};

		function setAddressInfosInLocalStorage(addressInfos) {
			console.assert(Array.isArray(addressInfos));
			localStorageNamespaced.setItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY, addressInfos);
		}

		function getAddressInfosFromLocalStorage() {
			const addressInfosDeserialized = localStorageNamespaced.getItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY);
			if (Array.isArray(addressInfosDeserialized)) {
				// Convert deserialized addressInfos to new AddressInfo objects because the serialized json has no functions.
				return addressInfosDeserialized.map(addressInfoData => Object.assign(new AddressInfo(), addressInfoData));
			}
			return [];
		}

		function setPriceInLocalStorage(price) {
			if (price == null) {
				return;
			}
			console.assert(typeof price == 'number');
			localStorageNamespaced.setItem(PRICE_LOCAL_STORAGE_KEY, price);
		}

		function getPriceFromLocalStorage() {
			return parseFloat(localStorageNamespaced.getItem(PRICE_LOCAL_STORAGE_KEY)) || null;
		}

		function backupToFile() {
			const suggestedFileName = 'bitcoin-address-watcher-backup-' + Math.floor(Date.now() / 1000).toString() + '.json';
			const localStorageString = localStorageNamespaced.toFormattedString();
			// https://stackoverflow.com/a/18197341
			const element = document.createElement('a');
			element.href = 'data:application/json;charset=utf-8,' + encodeURIComponent(localStorageString);// encodeURIComponent allows file to contain '#' characters.
			element.download = suggestedFileName;
			element.style.display = 'none';
			document.body.appendChild(element);
			element.click();
			document.body.removeChild(element);
		}

		async function fetchPriceFromPoloniex() {
			const url = 'https://poloniex.com/public?command=returnTicker';

			const response = await fetch(url);

			if (!response.ok) {
				throw new Error(`Request for price rejected with status ${response.status}`);
			}

			const responseJSON = await response.json();

			return parseFloat(responseJSON.USDC_BCHSV.last) / 100000000;
		}

		async function fetchPriceFromBlockchair() {
			const url = 'https://api.blockchair.com/bitcoin-sv/stats';

			const response = await fetch(url);

			if (!response.ok) {
				throw new Error(`Request for price rejected with status ${response.status}`);
			}

			const responseJSON = await response.json();

			const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
			const market_cap_usd = data.market_cap_usd;
			const circulation = data.circulation;

			if (typeof market_cap_usd != 'number' || typeof circulation != 'number' || circulation < 1763916464692325) {
				throw new Error(`Unable to derive price from market cap of ${market_cap_usd} and circulation of ${circulation}`);
			}

			return market_cap_usd / circulation;
		}

		async function fetchPrice() {
			const errorMessages = [];

			try {
				return await fetchPriceFromPoloniex();
			} catch (err) {
				console.log(err);
				errorMessages.push(`Error updating price from Poloniex: ${err.message}`);
			}

			try {
				return await fetchPriceFromBlockchair();
			} catch (err) {
				console.log(err);
				errorMessages.push(`Error updating price from Blockchair: ${err.message}`);
			}

			throw new Error(`${errorMessages.length > 1 ? 'Error updating price from all sources:\n' : ''}${errorMessages.join(',\n')}.`);
		}

		async function updateAddressInfosFromBitindex(addressInfos) {
			console.assert(addressInfos.length);

			// Convert AddressInfo array to address (string) array.
			const addresses = addressInfos.map(addressInfo => addressInfo.address);

			// Addresses can be comma-separated values.
			const url = `https://api.bitindex.network/api/v2/addrs/balance?address=${addresses.join(',')}`;

			const response = await fetch(url);

			if (!response.ok) {
				throw new Error(`Request for address info rejected with status ${response.status}`);
			}

			const responseJSON = await response.json();
			/* Example responseJSON:
				{
					"data": [
						{
							"address": "1BitcoinEaterAddressDontSendf59kuE",
							"confirmed": 63791,
							"unconfirmed": 0
						},
						{
							"address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
							"confirmed": 1392000,
							"unconfirmed": 144237
						}
					]
				}
			*/

			const data = responseJSON.data;// Expecting returned JSON to have a "data" property.

			if (!Array.isArray(data) || data.length != addressInfos.length) {
				throw new Error('Invalid data received when fetching address balances');
			}

			for (let i = 0; i < data.length; i++) {
				const confirmed = data[i].confirmed;
				const unconfirmed = data[i].unconfirmed;
				if (typeof confirmed == 'number' && typeof unconfirmed == 'number') {
					addressInfos[i].balanceLastUpdate = addressInfos[i].balance;
					addressInfos[i].balance = confirmed + unconfirmed;
				}
				// addressInfos[i].balance may be a number or the default initial value.
			}
		}

		async function updateAddressInfos(addressInfos) {
			console.assert(addressInfos.length);

			const errorMessages = [];

			/* Example for how to add an address info update source:
			try {
				// Use ____ first because it can update AddressInfo spent property.
				await updateAddressInfosFrom____(addressInfos);
				return;
			} catch (err) {
				console.log(err);
				errorMessages.push(`Error updating address info from ____: ${err.message}`);
			}
			*/

			try {
				await updateAddressInfosFromBitindex(addressInfos);
				return;
			} catch (err) {
				console.log(err);
				errorMessages.push(`Error updating address info from Bitindex: ${err.message}`);
			}

			throw new Error(`${errorMessages.length > 1 ? 'Error updating address info from all sources:\n' : ''}${errorMessages.join(',\n')}.`);
		}

		// Requests both at the same time.
		async function fetchAddressInfosAndPrice(addressInfos) {
			// Start fetching price now. To be 'await'ed later.
			const pricePromise = fetchPrice()
				.catch(error => {
					console.log(error.message);
					const priceFromLocalStorage = getPriceFromLocalStorage();
					if (priceFromLocalStorage) {
						alert(error.message);
					}
					return priceFromLocalStorage;
				});

			if (addressInfos.length) {
				await updateAddressInfos(addressInfos);
			}

			const price = await pricePromise;

			return { addressInfos, price };
		}

		function render(addressInfos, price) {
			setAddressInfosInLocalStorage(addressInfos);
			setPriceInLocalStorage(price);

			const totalBalance = addressInfos.reduce((t, address) => t + address.balance || 0, 0);
			const totalBalanceChange = addressInfos.reduce((t, address) => t + address.balanceChange, 0);
			const totalValuation = addressInfos.reduce((t, address) => t + (address.balance && price ? address.balance * price : 0), 0);
			const totalBalanceDisplayString = totalBalance.toLocaleString();
			const totalValuationDisplayString = totalValuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

			const headersContainer = document.getElementById('headersContainer');
			while (headersContainer.firstChild) {
				// Remove current headers. https://stackoverflow.com/a/3955238
				headersContainer.removeChild(headersContainer.firstChild);
			}

			const addressesTableContainer = document.getElementById('addressesTableContainer');
			while (addressesTableContainer.firstChild) {
				// Remove current table. https://stackoverflow.com/a/3955238
				addressesTableContainer.removeChild(addressesTableContainer.firstChild);
			}

			const removeAddressesButtonsContainer = document.getElementById('removeAddressesButtonsContainer');
			while (removeAddressesButtonsContainer.firstChild) {
				// Remove current remove addresses buttons. https://stackoverflow.com/a/3955238
				removeAddressesButtonsContainer.removeChild(removeAddressesButtonsContainer.firstChild);
			}

			const totalBalanceHeader = document.createElement('h1');
			totalBalanceHeader.id = 'totalBalanceHeader';
			totalBalanceHeader.appendChild(document.createTextNode(`Balance: ${totalBalanceDisplayString}`));
			headersContainer.appendChild(totalBalanceHeader);

			if (addressInfos.length == 0) {
				return;
			}

			if (price) {
				const totalValuationHeader = document.createElement('h1');
				totalValuationHeader.id = 'totalValuationHeader';
				totalValuationHeader.appendChild(document.createTextNode(`${totalValuationDisplayString} USD`));
				headersContainer.appendChild(totalValuationHeader);
			}

			const addressesTable = document.createElement('table');
			addressesTable.classList.add('standardMargin');

			// First row.
			addressesTable.appendChild((() => {
				const tr = document.createElement('tr');
				tr.appendChild(document.createElement('th'));
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Label'));
					return th;
				})());
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Address'));
					return th;
				})());
				tr.appendChild((() => {
					const th = document.createElement('th');
					th.appendChild(document.createTextNode('Balance'));
					return th;
				})());
				if (price) {
					tr.appendChild((() => {
						const th = document.createElement('th');
						th.appendChild(document.createTextNode('USD'));
						return th;
					})());
				}
				tr.appendChild(document.createElement('th'));
				return tr;
			})());

			for (let i = 0; i < addressInfos.length; i++) {
				const addressInfo = addressInfos[i];
				const balanceLastUpdate = addressInfo.balanceLastUpdate;
				const balance = addressInfo.balance;
				const balanceChange = addressInfo.balanceChange;
				const spent = addressInfo.spent;
				const valuation = balance == null || price == null ? null : balance * price;
				const balanceDisplayString = balance == null ? '' : balance.toLocaleString();
				const valuationDisplayString = valuation == null ? '' : valuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

				if (balanceChange != 0) {
					console.log(`Balance change for address ${i + 1}: ${balanceChange} (from ${balanceLastUpdate} to ${balance}).`);
				}

				addressesTable.appendChild((() => {
					const tr = document.createElement('tr');
					tr.appendChild((() => {
						// Delete address button.
						const td = document.createElement('td');
						td.classList.add('tdWithInput');
						td.appendChild((() => {
							const button = document.createElement('button');
							button.classList.add('labelInput');
							button.classList.add('labelInputButton');
							button.classList.add('deleteAddressButton');
							button.type = 'button';
							button.title = `Remove address ${i + 1}`;
							button.appendChild(document.createTextNode('X'));
							button.onclick = () => { removeAddressInfosIndex(i); };
							return button;
						})());
						return td;
					})());
					tr.appendChild((() => {
						// Label input.
						const td = document.createElement('td');
						td.classList.add('tdWithInput');
						td.appendChild((() => {
							const input = document.createElement('input');
							input.classList.add('labelInput');
							input.type = 'text';
							input.title = `Remove address ${i + 1}`;
							input.value = addressInfo.label;
							input.onchange = () => { updateAddressInfosLabelFromIndex(i, input.value); };
							return input;
						})());
						return td;
					})());
					tr.appendChild((() => {
						// Address.
						const td = document.createElement('td');
						td.classList.add('textLeft');
						if (addressInfo.note) {
							// Hover text using AddressInfo note.
							td.title = addressInfo.note;
						}
						td.appendChild(document.createTextNode(addressInfo.address));
						return td;
					})());
					tr.appendChild((() => {
						// Balance.
						const td = document.createElement('td');
						td.classList.add('textRight');
						if (balanceChange) {
							td.classList.add(balanceChange > 0 ? 'increaseColor' : 'decreaseColor');
							td.title = balanceChange > 0 ? `+${balanceChange.toLocaleString()}` : `-${Math.abs(balanceChange).toLocaleString()}`;
						}
						if (spent) {
							if (!balanceChange) {
								// Make sure balance change color has priority independent of CSS ordering.
								td.classList.add('spentColor');
							}
							if (td.title) {
								td.title += '\n';
							}
							if (balance) {
								td.title += 'Warning: This address has been re-used after being involved in a spent transaction.';
							} else {
								td.title += 'This address has been involved in a spent transaction.';
							}
						}
						td.appendChild(document.createTextNode(balanceDisplayString));
						return td;
					})());
					if (price) {
						tr.appendChild((() => {
							// USD.
							const td = document.createElement('td');
							td.classList.add('textRight');
							td.appendChild(document.createTextNode(valuationDisplayString));
							return td;
						})());
					}
					tr.appendChild((() => {
						// Block explorer link.
						const td = document.createElement('td');
						td.classList.add('tdImageButton');
						td.appendChild((() => {
							const a = document.createElement('a');
							a.href = `https://blockchair.com/bitcoin-sv/address/${addressInfo.address}`;
							a.target = '_blank';
							a.title = 'View on block explorer';
							a.appendChild((() => {
								const img = document.createElement('img');
								img.src = 'https://blockchair.com/favicon.ico';
								img.alt = 'View';
								return img;
							})());
							return a;
						})());
						return td;
					})());
					return tr;
				})());
			}

			if (addressInfos.length > 1) {
				if (totalBalanceChange != 0) {
					console.log(`Total balance change: ${totalBalanceChange}.`);
				}

				// Last row.
				addressesTable.appendChild((() => {
					const tr = document.createElement('tr');
					tr.appendChild(document.createElement('th'));
					tr.appendChild(document.createElement('th'));
					tr.appendChild((() => {
						const th = document.createElement('th');
						th.classList.add('textRight');
						th.appendChild(document.createTextNode('Total:'));
						return th;
					})());
					tr.appendChild((() => {
						// Total balance.
						const td = document.createElement('td');
						td.classList.add('textRight');
						if (totalBalanceChange != 0) {
							td.classList.add(totalBalanceChange > 0 ? 'increaseColor' : 'decreaseColor');
							td.title = totalBalanceChange > 0 ? `+${totalBalanceChange.toLocaleString()}` : `-${Math.abs(totalBalanceChange).toLocaleString()}`;
						}
						td.appendChild(document.createTextNode(totalBalanceDisplayString));
						return td;
					})());
					if (price) {
						tr.appendChild((() => {
							// Total USD.
							const td = document.createElement('td');
							td.classList.add('textRight');
							td.appendChild(document.createTextNode(totalValuationDisplayString));
							return td;
						})());
					}
					tr.appendChild(document.createElement('th'));
					return tr;
				})());

				// Remove multiple address buttons.
				const createRemoveAddressesButton = function (onclick, value, title) {
					console.assert(onclick instanceof Function);
					console.assert(value);
					const button = document.createElement('input');
					button.type = 'button';
					button.classList.add('labelInput');
					button.classList.add('labelInputButton');
					button.classList.add('standardMargin');
					button.onclick = onclick;
					button.value = value;
					if (title) {
						button.title = title;
					}
					return button;
				};
				removeAddressesButtonsContainer.appendChild(createRemoveAddressesButton(removeAddressInfosContainingPromptLabel, 'Remove Labels Containing'));
				removeAddressesButtonsContainer.appendChild(createRemoveAddressesButton(removeAddressInfosMatchingPromptLabel, 'Remove Labels Matching'));
				removeAddressesButtonsContainer.appendChild(createRemoveAddressesButton(removeAddressInfosBalanceOfZero, 'Remove Valueless'));
				removeAddressesButtonsContainer.appendChild(createRemoveAddressesButton(removeAddressInfos, 'Remove All'));
			}

			addressesTableContainer.appendChild(addressesTable);
		}

		function removeAddressInfosBalanceOfZero() {
			if (!confirm('Remove addresses with a balance of 0?')) {
				return;
			}
			render(
				getAddressInfosFromLocalStorage().filter(address => address.balance),
				getPriceFromLocalStorage()
			);
		}

		function removeAddressInfosMatchingPromptLabel() {
			const input = prompt('Remove addresses with label matching text (or leave blank to remove all unlabeled addresses):');
			if (input == null) {
				return;
			}
			render(
				getAddressInfosFromLocalStorage().filter(address => address.label != input),
				getPriceFromLocalStorage()
			);
		}

		function removeAddressInfosContainingPromptLabel() {
			const input = prompt('Remove addresses with label containing text:');
			if (!input) {
				return;
			}
			render(
				getAddressInfosFromLocalStorage().filter(address => !address.label.includes(input)),
				getPriceFromLocalStorage()
			);
		}

		function removeAddressInfos() {
			if (!confirm('Remove all addresses?')) {
				return;
			}
			render(/* addressInfos */[], getPriceFromLocalStorage());
		}

		function removeAddressInfosIndex(index) {
			if (
				Date.now() > confirmDeletingAddressAfterTime &&
				!confirm(`Remove address ${index + 1}?`)
			) {
				// Prevent accidentally removing an address.
				return;
			}
			const addressInfos = getAddressInfosFromLocalStorage();
			const price = getPriceFromLocalStorage();
			addressInfos.splice(index, 1);
			render(addressInfos, price);
			confirmDeletingAddressAfterTime = Date.now() + 3000;
		}

		function updateAddressInfosLabelFromIndex(index, label) {
			const addressInfos = getAddressInfosFromLocalStorage();
			addressInfos[index].label = label;
			setAddressInfosInLocalStorage(addressInfos);
		}

		// Download balance for each new AddressInfo, update price, and then update UI.
		function setupAddressInfosAndRender(addressInfos, scrollOnSuccess = false) {
			fetchAddressInfosAndPrice(addressInfos)
				.then(addressInfosAndPrice => {
					render(addressInfosAndPrice.addressInfos, addressInfosAndPrice.price);
					if (scrollOnSuccess) {
						window.scrollTo(0, document.body.scrollHeight);
					}
				})
				.catch(error => {
					console.log(error.message);
					alert(error.message);
				});
		}

		function renderUpdateRender() {
			const addressInfos = getAddressInfosFromLocalStorage();

			// Unset all the balanceLastUpdate because rendering balance changes the first time is pointless.
			const defaultBalanceLastUpdate = new AddressInfo().balanceLastUpdate;
			for (let addressInfo of addressInfos) {
				addressInfo.balanceLastUpdate = defaultBalanceLastUpdate;
			}

			// Render before fetching any external data.
			render(addressInfos, getPriceFromLocalStorage());

			if (addressInfos.length) {
				setupAddressInfosAndRender(addressInfos);
			}
		}

		function loadFromFileAndRender(inputTarget) {
			// https://stackoverflow.com/a/29176118
			const reader = new FileReader();
			reader.onload = function () {
				const text = reader.result;
				try {
					localStorageNamespaced.setStorageObject(JSON.parse(text));
					console.log('Loaded from file.');
					renderUpdateRender();
				} catch (err) {
					const errorMessage = `Unable to parse JSON backup file: ${err.message}`;
					console.log(errorMessage);
					alert(errorMessage);
				}
			};
			reader.onerror = function (event) {
				reader.abort();
				const errorMessage = 'Error reading file.';
				console.log(errorMessage);
				alert(errorMessage);
			};
			reader.readAsText(inputTarget.files[0]);
			inputTarget.value = '';// Reset value so onchange() works when reloading from file again.
		}

		function addInputAddresses() {
			const inputAddresses = document.getElementById("inputAddresses");
			const addresses = inputAddresses.value
				.split(',')
				.map(a => a.replace(/[^A-Z0-9]+/ig, ''))// Remove undesirable characters.
				.filter(a => a.length != 0);// Remove empty addresses.

			if (addresses.length == 0) {
				alert(`No valid addresses to add.`);
				return;
			}

			inputAddresses.value = '';

			// Convert addresses to AddressInfo objects and combine with the AddressInfos from localStorage.
			const addressInfos = getAddressInfosFromLocalStorage().concat(addresses.map(a => new AddressInfo(a)));

			setupAddressInfosAndRender(addressInfos, /* scrollOnSuccess */true);
		}

		window.onload = function () {
			renderUpdateRender();
		}

	</script>

	<style>
		body {
			background-color: #000;
			color: #ccc;
			text-align: center;
			font-family: "Times New Roman", Times, serif;
		}

		table {
			background: #002;
			border: 0.1em solid #666;
			border-spacing: 0.2em;
			border-radius: 0.6em;
		}

		th {
			background-color: #005;
			color: #ddd;
			vertical-align: middle;
			padding: 0.2em;
			font-size: 1.2em;
		}

		td {
			background-color: #004;
			color: #eee;
			vertical-align: middle;
			padding: 0.2em;
			font-family: "Courier New", Courier, monospace;
			min-width: 1.6em;
		}

		td img {
			display: block;
			object-fit: contain;
			height: 1.6em;
			max-width: 16em;
			margin: 0 auto;
		}

		a,
		a:visited,
		a:hover,
		a:active {
			color: inherit;
		}

		.container {
			margin: 0 auto 10em;
			display: inline-block;
		}

		.textLeft {
			text-align: left;
		}

		.textRight {
			text-align: right;
		}

		td.textRight,
		td.textLeft {
			padding-left: 0.6em;
			padding-right: 0.6em;
		}

		td.tdWithInput {
			padding: 0;
			background-color: transparent;
		}

		td.tdImageButton {
			padding: 0;
		}

		button.deleteAddressButton {
			color: #d00;
		}

		.spentColor {
			color: #dd0;
		}

		.increaseColor {
			color: #0d0;
		}

		.decreaseColor {
			color: #d00;
		}

		.labelInput {
			background-color: #000;
			color: #ddd;
			border: 0.1em solid #666;
			text-align: center;
			padding: 0.1em 0.4em;
			text-decoration: none;
			font: 400 1.1em Arial;
			text-rendering: auto;
			letter-spacing: normal;
			word-spacing: normal;
			text-transform: none;
			text-indent: 0px;
			text-shadow: none;
			display: inline-block;
			border-radius: 0.3em;
		}

		.labelInputButton {
			cursor: pointer;
		}

		.labelInputButton:hover {
			background-color: #005;
		}

		.standardMargin {
			margin: 0.5em 0.25em 0;
		}
	</style>

</head>

<body>

	<div class="container">

		<div id="headersContainer"></div>

		<input id="inputAddresses" class="labelInput" type="text" size="64"
			placeholder="Input one or more addresses separated by commas" />
		<input class="labelInput labelInputButton" type="button" value="Add Addresses" onclick="addInputAddresses()" />

		<div id="addressesTableContainer"></div>

		<div id="removeAddressesButtonsContainer"></div>

		<label class="labelInput labelInputButton standardMargin">
			<input style="display: none;" type="file" accept=".json" onchange="loadFromFileAndRender(event.target)" />
			Import
		</label><input class="labelInput labelInputButton standardMargin" type="button" value="Export"
			onclick="backupToFile()" />

	</div>

</body>

</html>