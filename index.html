<!DOCTYPE html>
<html>

<head>

	<title>Bitcoin Address Watcher</title>

	<script>

		class AddressInfo {
			constructor(address, label = '', note = '') {
				this.address = address;
				this.label = label;
				this.note = note;
				this.balance = null;
				this.spent = null;
			}
		}

		const ADDRESS_INFOS_LOCAL_STORAGE_KEY = 'addressInfos';
		const PRICE_LOCAL_STORAGE_KEY = 'price';

		let confirmDeletingAddressAfterTime = new Date().getTime();

		function setAddressInfosInLocalStorage(addressInfos) {
			localStorage.setItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY, JSON.stringify(addressInfos));
		}

		function getAddressInfosFromLocalStorage() {
			const addressInfosString = localStorage.getItem(ADDRESS_INFOS_LOCAL_STORAGE_KEY);
			if (addressInfosString) {
				try {
					return JSON.parse(addressInfosString);
				} catch (err) {
					console.log('Unable to parse address info from localStorage:', err.message);
				}
			}
			return [];
		}

		function setPriceInLocalStorage(price) {
			localStorage.setItem(PRICE_LOCAL_STORAGE_KEY, price.toString());
		}

		function getPriceFromLocalStorage() {
			const priceString = localStorage.getItem(PRICE_LOCAL_STORAGE_KEY);
			if (priceString) {
				try {
					return parseFloat(priceString);
				} catch (err) {
					console.log('Unable to parse price from localStorage:', err.message);
				}
			}
			return NaN;
		}

		async function fetchPrice() {
			const url = 'https://api.blockchair.com/bitcoin-sv/stats';

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for price rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					const market_cap_usd = data.market_cap_usd;
					const circulation = data.circulation;
					if (isNaN(market_cap_usd) || isNaN(circulation) || circulation < 1763916464692325) {
						throw new Error(`Unable to derive price from market cap of ${market_cap_usd} and circulation of ${circulation}`);
					}
					return market_cap_usd / circulation;
				});
		}

		async function fetchAddressBalances(addressInfos) {
			if (addressInfos.length == 0) {
				return;
			}

			// Convert AddressInfo array to address (string) array.
			const addresses = addressInfos.map(addressInfo => addressInfo.address);

			// Addresses can be comma-separated values.
			const url = `https://api.bitindex.network/api/v2/addrs/balance?address=${addresses.join(',')}`;

			return fetch(url)
				.then(response => {
					if (response.ok) {
						return response.json();
					}
					throw new Error(`Request for address info rejected with status ${response.status}`);
				})
				.then(responseJSON => {
					/* Example responseJSON:
						{
							"data": [
								{
									"address": "1BitcoinEaterAddressDontSendf59kuE",
									"confirmed": 63791,
									"unconfirmed": 0
								},
								{
									"address": "1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa",
									"confirmed": 1392000,
									"unconfirmed": 144237
								}
							]
						}
					*/
					const data = responseJSON.data;// Expecting returned JSON to have a "data" property.
					if (!Array.isArray(data) || data.length != addressInfos.length) {
						throw new Error('Invalid data received when fetching address balances');
					}
					for (let i = 0; i < data.length; i++) {
						const confirmed = data[i].confirmed;
						const unconfirmed = data[i].unconfirmed;
						if (!isNaN(confirmed) && !isNaN(unconfirmed)) {
							addressInfos[i].balance = confirmed + unconfirmed;
						}
						// addressInfos[i].balance may be a number or the default initial value.
					}
				});
		}

		// Requests both at the same time.
		async function fetchAddressInfosAndPrice(addressInfos) {
			// Start fetching price now. To be 'await'ed later.
			const pricePromise = fetchPrice()
				.catch(error => {
					const errorMessage = `Error fetching price: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
					return getPriceFromLocalStorage();
				});

			await fetchAddressBalances(addressInfos);

			const price = await pricePromise;// May be NaN because of getPriceFromLocalStorage();

			return { addressInfos, price };
		}

		function renderTable(addressInfos, price) {
			setAddressInfosInLocalStorage(addressInfos);
			setPriceInLocalStorage(price);

			const addressesTable = document.getElementById("addressesTable");

			if (addressInfos.length == 0) {
				addressesTable.innerHTML = '';
				addressesTable.style.display = 'none';
				return;
			}

			addressesTable.style.display = '';

			let tableInnerHTML = "<tr><th></th><th>Label</th><th>Address</th><th>Balance</th><th>USD</th><th></th></tr>";

			for (let i = 0; i < addressInfos.length; i++) {
				const balance = addressInfos[i].balance;
				const valuation = balance == null || price == null ? null : balance * price;
				const balanceDisplayString = balance == null ? '' : balance.toLocaleString();
				const valuationDisplayString = valuation == null ? '' : valuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

				// Hover text using AddressInfo note.
				const addressNoteTitleHTML = (addressInfos.note ? ' title="' + addressInfos.note + '"' : '');

				tableInnerHTML +=
					`<tr>
						<td><button type="button" class="deleteAddressButton" title="Remove address ${i + 1}" onclick="removeAddressInfosIndex(${i})">X</button></td>
						<td${addressNoteTitleHTML}><input type="text" class="labelInput" onchange="updateAddressInfosLabelFromIndex(${i}, this.value)" value="${addressInfos[i].label}"></td>
						<td class="textLeft">${addressInfos[i].address}</td>
						<td class="textRight">${balanceDisplayString}</td>
						<td class="textRight">${valuationDisplayString}</td>
						<td><a href="https://blockchair.com/bitcoin-sv/address/${addressInfos[i].address}" target="_blank" title="View on block explorer"><img src="https://blockchair.com/favicon.ico" alt="View"></a></td>
					</tr>`;
			}

			const totalBalance = addressInfos.reduce((t, address) => t + address.balance || 0, 0);
			const totalValuation = addressInfos.reduce((t, address) => t + (address.balance && price ? address.balance * price : 0), 0);
			const totalBalanceDisplayString = totalBalance.toLocaleString();
			const totalValuationDisplayString = totalValuation.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

			if (addressInfos.length > 1) {
				tableInnerHTML +=
					`<tr>
						<th></th>
						<th></th>
						<th class="textRight">Total:</th>
						<td class="textRight">${totalBalanceDisplayString}</td>
						<td class="textRight">${totalValuationDisplayString}</td>
						<th></th>
					</tr>`;
			}

			document.getElementById('totalBalanceHeader').innerHTML = `Balance: ${totalBalanceDisplayString}`;
			document.getElementById('totalValuationHeader').innerHTML = `${totalValuationDisplayString} USD`;
			addressesTable.innerHTML = tableInnerHTML;
		}

		function removeAddressInfosIndex(index) {
			if (
				new Date().getTime() > confirmDeletingAddressAfterTime &&
				!confirm(`Remove address ${index + 1}?`)
			) {
				// Prevent accidentally removing an address.
				return;
			}
			const addressInfos = getAddressInfosFromLocalStorage();
			const price = getPriceFromLocalStorage();
			addressInfos.splice(index, 1);
			renderTable(addressInfos, price);
			confirmDeletingAddressAfterTime = new Date().getTime() + 3000;
		}

		function updateAddressInfosLabelFromIndex(index, label) {
			const addressInfos = getAddressInfosFromLocalStorage();
			addressInfos[index].label = label;
			setAddressInfosInLocalStorage(addressInfos);
		}

		// Download balance for each new AddressInfo, update price, and then update UI.
		function setupAddressInfosAndRender(addressInfos, scrollOnSuccess = false) {
			fetchAddressInfosAndPrice(addressInfos)
				.then(addressInfosAndPrice => {
					renderTable(addressInfosAndPrice.addressInfos, addressInfosAndPrice.price);
					if (scrollOnSuccess) {
						window.scrollTo(0, document.body.scrollHeight);
					}
				})
				.catch(error => {
					const errorMessage = `Error fetching address balances: ${error.message}`;
					console.log(errorMessage);
					alert(errorMessage);
				});
		}

		window.onload = function () {
			document.getElementById("addAddressesButton").onclick = function () {
				const inputAddresses = document.getElementById("inputAddresses");
				const addresses = inputAddresses.value
					.split(',')
					.map(a => a.replace(/[^A-Z0-9]+/ig, ''))// Remove undesirable characters.
					.filter(a => a.length != 0);// Remove empty addresses.

				if (addresses.length == 0) {
					alert(`No valid addresses to add.`);
					return;
				}

				inputAddresses.value = '';

				// Convert addresses to AddressInfo objects and combine with the AddressInfos from localStorage.
				const addressInfos = getAddressInfosFromLocalStorage().concat(addresses.map(a => new AddressInfo(a)));

				setupAddressInfosAndRender(addressInfos, /* scrollOnSuccess */true);
			};

			// Hide table before loading data.
			document.getElementById("addressesTable").style.display = 'none';

			const addressInfos = getAddressInfosFromLocalStorage();
			if (addressInfos.length) {
				setupAddressInfosAndRender(addressInfos);
			}
		}

	</script>

	<style>
		body {
			background-color: #000;
			color: #ccc;
			text-align: center;
		}

		table {
			background: #002;
			margin: 0 auto;
			border: 0.1em solid #666;
			font-size: 1.2em;
			border-spacing: 0.2em;
		}

		th {
			background-color: #008;
			color: #ddd;
			vertical-align: middle;
			padding: 0.2em;
			font-size: 1.2em;
		}

		td {
			background-color: #006;
			color: #eee;
			vertical-align: middle;
			padding: 0.2em;
			font-family: "Courier New", Courier, monospace;
		}

		td img {
			display: block;
			height: 100%;
			width: auto;
		}

		a,
		a:visited,
		a:hover,
		a:active {
			color: inherit;
		}

		.container {
			margin: 0 auto 10em;
			display: inline-block;
		}

		.textLeft {
			text-align: left;
		}

		.textRight {
			text-align: right;
		}

		td.textRight,
		td.textLeft {
			padding-left: 0.6em;
			padding-right: 0.6em;
		}

		.deleteAddressButton {
			background-color: #000;
			color: #d00;
			border: 0.1em solid #666;
			border-radius: 0.3em;
			font-size: 1em;

		}

		.labelInput {
			background-color: #000;
			color: #ddd;
			border: 0.1em solid #666;
			text-align: center;
			font-size: 1.1em;
		}
	</style>

</head>

<body>

	<div class="container">

		<h1 id="totalBalanceHeader"></h1>
		<h1 id="totalValuationHeader"></h1>

		<div style="text-align: center; margin-bottom: 1em;">
			<input id="inputAddresses" class="labelInput" type="text" size="64"
				placeholder="Input one or more addresses separated by commas" />
			<input id="addAddressesButton" class="labelInput" type="button" value="Add Addresses" />
		</div>

		<table id="addressesTable">
		</table>

	</div>

</body>

</html>